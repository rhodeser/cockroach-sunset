//////////////////////////////////////////////////////////////////////////////////
// Create Date:    04/30/2014  by Caren Zgheib using Erik Rohdes' code
// Module Name:    my_lightsensor.v 
// Project Name:   ECE544: project 2
// Target Devices: Nexys 3
// Description:    Pulse Width Detection module that detrmines the high time
// 				and period of the signal generated by the TSL235R-LF light to
// 				frequency converter.
//
// It takes the frequency output as an input and counts the high and period.
// It only updates the final high time and final period time when the detection is done.
// Therefore, the application can read whenever it needs the values without the need for an interrupt.
//
// The controller Inputs and Outputs are as follows:
//
// CLK			I			Clock input. 100MHz if connected to system clock
// 
// RESET		I			Connected to system reset.
//
// FREQ_OUT		I			Signal generated by the light to frequency converter
//
// ENABLE		I			Is asserted high when the periferal is enabled
//
// HIGH_TIME	O			Detected high_time
//
// PERIOD		O			Detected period
//////////////////////////////////////////////////////////////////////////////////


module my_lightsensor(
		input clk,					// system clock
		input reset,				// system reset
		input freq_out,				// the generated frequency signal
		input enable,				// enable periferal
		output reg [31:0] high_time,// detected high time
		output reg [31:0] period	// detected period
);

reg [31:0] high = 32'd0;
reg [31:0] low = 32'd0;
reg prev_level, curr_level;

always @(posedge clk)
begin
    prev_level <= curr_level;
    curr_level <= freq_out;
end

// use rising edge detection for output enable
wire rising_edge = ~prev_level & curr_level;

always @(posedge clk)
begin
    if (rising_edge)
    begin
        // send local count to output registers for software access on GPIOs
        high_time   <= high;
        period    <=  low + high; 
        // clear local counters (start high at 1 since it's on the rising edge
        high <= 32'd1;
        low  <= 32'd0;
    end
	 
    else
	 begin
            // increment appropriate counter depending on PWM level
        if (curr_level)
            high <= high + 1'b1;
        else
            low  <= low  + 1'b1;
    end
end
endmodule //my_lightsensor

