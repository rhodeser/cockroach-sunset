//////////////////////////////////////////////////////////////////////////////////
// Create Date:    04/30/2014  by Caren Zgheib
// Module Name:    my_lightsensor.v 
// Project Name:   ECE544: project 2
// Target Devices: Nexys 3
// Description:    Pulse Width Detection module that detrmines the high time
// 				and period of the signal generated by the TSL235R-LF light to
// 				frequency converter.
//
// It takes the frequency output as an input and counts the high and period.
// It only updates the final high time and final period time when the detection is done.
// Therefore, the application can read whenever it needs the values without the need for an interrupt.
//
// The controller Inputs and Outputs are as follows:
//
// CLK			I			Clock input. 100MHz if connected to system clock
// 
// RESET		I			Connected to system reset.
//
// FREQ_OUT		I			Signal generated by the light to frequency converter
//
// ENABLE		I			Is asserted high when the periferal is enabled
//
// HIGH_TIME	O			Detected high_time
//
// PERIOD		O			Detected period
//////////////////////////////////////////////////////////////////////////////////


module my_lightsensor(
		input clk,					// system clock
		input reset,				// system reset
		input freq_out,				// the generated frequency signal
		input enable,				// enable periferal
		output [31:0] high_time,	// detected high time
		output [31:0] period		// detected period
);


// Define States
parameter	RESET 		= 0;
parameter	IDLE		= 1;
parameter	COUNT_HIGH	= 2;
parameter	COUNT_LOW	= 3;
parameter	UPDATE		= 4;

// Define Internal Registers
reg [2:0]	state, next_state;
reg [31:0]	high_time_int, period_int, high_time_final, period_final;


always @(posedge clk) begin
	if (reset)
		state <= RESET;
	else if (~enable)
		state <= IDLE;
	else
		state <= next_state;
end	


always @(posedge clk) begin
	case (state)
		RESET: begin
			high_time_final	<= 32'd0;
			period_final	<= 32'd0;
			next_state <= reset ? RESET : IDLE;
			end
		
		IDLE: begin
			high_time_int	<= 32'd0;
			period_int		<= 32'd0;
			high_time_final <= high_time_final;
			period_final	<= period_final;

			if (~enable) 					next_state <= IDLE;
			
			else if (enable && freq_out) begin
					high_time_int	<= high_time_int + 1;
					period_int		<= period_int + 1;
					next_state <= COUNT_HIGH;
			end
			
			else							next_state <= IDLE;
			end

			COUNT_HIGH: begin
					if (freq_out) begin
							high_time_int	<= high_time_int + 1;
							period_int		<= period_int + 1;
							high_time_final <= high_time_final;
							period_final	<= period_final;

							next_state <= COUNT_HIGH;
					end
					else begin
							high_time_int	<= high_time_int;
							period_int		<= period_int + 1;
							high_time_final <= high_time_final;
							period_final	<= period_final;

							next_state <= COUNT_LOW;
					end
			end

			COUNT_LOW: begin
					if (!freq_out) begin
							high_time_int	<= high_time_int;
							period_int		<= period_int + 1;
							high_time_final <= high_time_final;
							period_final	<= period_final;

							next_state <= COUNT_LOW;
					end
					else
							next_state <= UPDATE;
			end

			UPDATE: begin
					high_time_final	<= high_time_int;
					period_final	<= period_int;
					
					next_state <= IDLE;
			end

			default: begin
					high_time_int	<= 32'd0;
					period_int		<= 32'd0;
					high_time_final <= high_time_final;
					period_final	<= period_final;

					next_state <= IDLE;
			end

		endcase
end 

assign high_time	= high_time_final;
assign period		= period_final;

endmodule //my_lightsensor

